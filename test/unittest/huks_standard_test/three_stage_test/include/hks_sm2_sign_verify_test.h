/*
 * Copyright (c) 2022 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef HKS_SM2_SIGN_VERIFY_TEST_H
#define HKS_SM2_SIGN_VERIFY_TEST_H

#include <string>
#include <vector>
#include "hks_in_data_array_after_hash_test_common.h"
#include "hks_three_stage_test_common.h"
namespace Unittest::Sm2SignVerify {
#ifdef _USE_OPENSSL_
static const std::string g_inData = "Hks_SM2_Sign_Verify_Test_0000000000000000000000000000000000000000000000000000000"
                                    "00000000000000000000000000000000000000000000000000000000000000000000000000000000"
                                    "0000000000000000000000000000000000000000000000000000000000000000000000000_string";
static const uint32_t SM2_COMMON_SIZE = 1024;
static uint8_t g_plainData[] = {
    0x22, 0x51, 0xFB, 0x88, 0x46, 0xDC, 0x87, 0xFA, 0x9D, 0x4C, 0x5E, 0x26, 0x79, 0xD7, 0x27, 0x01,
    0xF9, 0x7E, 0xD1, 0xD0, 0x70, 0x3E, 0x0A, 0x18, 0xD1, 0x2A, 0xFB, 0xAC, 0x79, 0x1E, 0xC8, 0xFB,
    0x4B, 0xCB, 0x05, 0x3F, 0xB4, 0x16, 0xDB, 0xD3, 0xF9, 0xE1, 0xD2, 0x9C, 0x59, 0x94, 0x32, 0x66,
    0xE6, 0xA6, 0x90, 0x78, 0xDA, 0x51, 0x99, 0xB0, 0x7C, 0x2D, 0x9F, 0x43, 0x3C, 0xC5, 0xDA, 0xAD,
    0xE6, 0xB3, 0x3F, 0x12, 0x64, 0xE9, 0x1D, 0x4E, 0x67, 0xAF, 0x0D, 0x02, 0x97, 0x21, 0x1F, 0x42,
};
static uint8_t g_hashData[] = {
    0x6D, 0xCE, 0x7A, 0x1F, 0xBA, 0xEA, 0xB7, 0x61, 0x39, 0xFE, 0x1C, 0xD6, 0xBA, 0x74, 0x8D, 0x9C,
    0xE4, 0x0C, 0xD1, 0x98, 0x2D, 0xF1, 0xB6, 0x93, 0x37, 0x89, 0xE4, 0x5F, 0xA4, 0xDC, 0xCB, 0x94,
};
static uint8_t g_signData[] = {
    0x30, 0x45, 0x02, 0x20, 0x36, 0x92, 0xA6, 0x84, 0x77, 0xE9, 0x13, 0x8B, 0x2D, 0x20, 0xC6, 0x70,
    0xEB, 0xD0, 0xE9, 0xE9, 0x35, 0x6B, 0x05, 0x09, 0xB8, 0x42, 0x75, 0x51, 0xA3, 0xB3, 0x54, 0xFB,
    0x77, 0x09, 0xED, 0x84, 0x02, 0x21, 0x00, 0xF9, 0x80, 0x3C, 0x5F, 0x70, 0x0E, 0xF5, 0x08, 0xCA,
    0x62, 0x4D, 0xF8, 0x0D, 0x02, 0x60, 0x68, 0xFA, 0x7E, 0xC8, 0x78, 0x0E, 0xA0, 0x9F, 0xF8, 0x7C,
    0x6C, 0x63, 0x74, 0x28, 0x14, 0x23, 0xB8,
};
static uint8_t g_keyPair[] = {
    0x96, 0x00, 0x00, 0x00, // algorithm(little endian): huks.HuksKeyAlg.HUKS_ALG_SM2 = 150
    0x00, 0x01, 0x00, 0x00, // length of key: 256 bits
    0x20, 0x00, 0x00, 0x00, // length of pkx：32 bytes
    0x20, 0x00, 0x00, 0x00, // length of pkx：32 bytes
    0x20, 0x00, 0x00, 0x00, // length of sk：32 bytes
    // pkx
    0xAE, 0xF7, 0xE4, 0x66, 0x4F, 0xE9, 0x60, 0xAB, 0xD5, 0x7F, 0x68, 0x0C, 0x65, 0xA9, 0x99, 0x18,
    0x61, 0x36, 0x3D, 0x08, 0x37, 0x8C, 0x85, 0xD3, 0xBA, 0x0A, 0xA8, 0x96, 0x01, 0xE9, 0x7F, 0xBF,
    // pky
    0x26, 0x2E, 0x80, 0x94, 0x77, 0x47, 0x83, 0xA7, 0x8C, 0x87, 0xE6, 0x3B, 0xE8, 0xBD, 0xB5, 0x7D,
    0x25, 0x42, 0x09, 0x7D, 0xC7, 0x09, 0x91, 0x0F, 0x88, 0x4C, 0x1E, 0x78, 0x98, 0xE3, 0x0C, 0xAF,
    // sk
    0x13, 0x9C, 0x30, 0x1A, 0x24, 0x30, 0x78, 0xF9, 0xDC, 0xB8, 0x48, 0x15, 0xA5, 0x6A, 0x2E, 0x24,
    0x18, 0x82, 0x19, 0xC5, 0xAB, 0x4E, 0xFB, 0x81, 0x4E, 0xCC, 0xAA, 0x66, 0x83, 0xA0, 0xC7, 0xAF,
};

struct GenerateKeyCaseParam {
    uint32_t id;
    int32_t result;
    std::vector<struct HksParam> params;
};

int HksSm2SignVerifyTest001(void);

int HksSm2SignVerifyTest002(void);

int HksSm2SignVerifyTest003(void);
#endif
}
#endif // HKS_SM2_SIGN_VERIFY_TEST_H

